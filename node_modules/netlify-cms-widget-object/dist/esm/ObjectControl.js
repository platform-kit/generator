"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactImmutableProptypes = _interopRequireDefault(require("react-immutable-proptypes"));

var _core = require("@emotion/core");

var _immutable = require("immutable");

var _netlifyCmsUiDefault = require("netlify-cms-ui-default");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject2() {
  const data = _taggedTemplateLiteral(["\n                    ", "\n                  "]);

  _templateObject2 = function _templateObject2() {
    return data;
  };

  return data;
}

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n                  ", "\n                "]);

  _templateObject = function _templateObject() {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const styleStrings = {
  nestedObjectControl: "\n    padding: 6px 14px 14px;\n    border-top: 0;\n    border-top-left-radius: 0;\n    border-top-right-radius: 0;\n  ",
  objectWidgetTopBarContainer: "\n    padding: ".concat(_netlifyCmsUiDefault.lengths.objectWidgetTopBarContainerPadding, ";\n  ")
};

class ObjectControl extends _react.default.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "componentValidate", {});

    _defineProperty(this, "validate", () => {
      const {
        field
      } = this.props;
      let fields = field.get('field') || field.get('fields');
      fields = _immutable.List.isList(fields) ? fields : (0, _immutable.List)([fields]);
      fields.forEach(field => {
        if (field.get('widget') === 'hidden') return;
        this.componentValidate[field.get('name')]();
      });
    });

    _defineProperty(this, "handleCollapseToggle", () => {
      this.setState({
        collapsed: !this.state.collapsed
      });
    });

    _defineProperty(this, "renderFields", (multiFields, singleField) => {
      if (multiFields) {
        return multiFields.map((f, idx) => this.controlFor(f, idx));
      }

      return this.controlFor(singleField);
    });

    this.state = {
      collapsed: false
    };
  }
  /*
   * Always update so that each nested widget has the option to update. This is
   * required because ControlHOC provides a default `shouldComponentUpdate`
   * which only updates if the value changes, but every widget must be allowed
   * to override this.
   */


  shouldComponentUpdate() {
    return true;
  }

  controlFor(field, key) {
    const {
      value,
      onChangeObject,
      onValidateObject,
      clearFieldErrors,
      metadata,
      fieldsErrors,
      editorControl: EditorControl,
      controlRef
    } = this.props;

    if (field.get('widget') === 'hidden') {
      return null;
    }

    const fieldName = field.get('name');
    const fieldValue = value && _immutable.Map.isMap(value) ? value.get(fieldName) : value;
    return (0, _core.jsx)(EditorControl, {
      key: key,
      field: field,
      value: fieldValue,
      onChange: onChangeObject,
      clearFieldErrors: clearFieldErrors,
      fieldsMetaData: metadata,
      fieldsErrors: fieldsErrors,
      onValidate: onValidateObject,
      processControlRef: controlRef && controlRef.bind(this),
      controlRef: controlRef
    });
  }

  render() {
    const {
      field,
      forID,
      classNameWrapper,
      forList
    } = this.props;
    const {
      collapsed
    } = this.state;
    const multiFields = field.get('fields');
    const singleField = field.get('field');

    if (multiFields || singleField) {
      return (0, _core.jsx)(_core.ClassNames, null, (_ref) => {
        let {
          css,
          cx
        } = _ref;
        return (0, _core.jsx)("div", {
          id: forID,
          className: cx(classNameWrapper, css(_templateObject(), styleStrings.objectWidgetTopBarContainer), {
            [css(_templateObject2(), styleStrings.nestedObjectControl)]: forList
          })
        }, forList ? null : (0, _core.jsx)(_netlifyCmsUiDefault.ObjectWidgetTopBar, {
          collapsed: collapsed,
          onCollapseToggle: this.handleCollapseToggle
        }), collapsed ? null : this.renderFields(multiFields, singleField));
      });
    }

    return (0, _core.jsx)("h3", null, "No field(s) defined for this widget");
  }

}

exports.default = ObjectControl;

_defineProperty(ObjectControl, "propTypes", {
  onChangeObject: _propTypes.default.func.isRequired,
  onValidateObject: _propTypes.default.func.isRequired,
  value: _propTypes.default.oneOfType([_propTypes.default.node, _propTypes.default.object, _propTypes.default.bool]),
  field: _propTypes.default.object,
  forID: _propTypes.default.string,
  classNameWrapper: _propTypes.default.string.isRequired,
  forList: _propTypes.default.bool,
  controlRef: _propTypes.default.func,
  editorControl: _propTypes.default.func.isRequired,
  resolveWidget: _propTypes.default.func.isRequired,
  clearFieldErrors: _propTypes.default.func.isRequired,
  fieldsErrors: _reactImmutableProptypes.default.map.isRequired
});

_defineProperty(ObjectControl, "defaultProps", {
  value: (0, _immutable.Map)()
});