"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPreviewStatus = exports.PreviewState = exports.isPreviewContext = exports.readFile = exports.branchFromContentKey = exports.contentKeyFromBranch = exports.parseContentKey = exports.generateContentKey = exports.statusToLabel = exports.labelToStatus = exports.isCMSLabel = exports.MERGE_COMMIT_MESSAGE = exports.DEFAULT_PR_BODY = exports.CMS_BRANCH_PREFIX = void 0;
const CMS_BRANCH_PREFIX = 'cms';
exports.CMS_BRANCH_PREFIX = CMS_BRANCH_PREFIX;
const DEFAULT_PR_BODY = 'Automatically generated by Netlify CMS';
exports.DEFAULT_PR_BODY = DEFAULT_PR_BODY;
const MERGE_COMMIT_MESSAGE = 'Automatically generated. Merged on Netlify CMS.';
exports.MERGE_COMMIT_MESSAGE = MERGE_COMMIT_MESSAGE;
const NETLIFY_CMS_LABEL_PREFIX = 'netlify-cms/';

const isCMSLabel = label => label.startsWith(NETLIFY_CMS_LABEL_PREFIX);

exports.isCMSLabel = isCMSLabel;

const labelToStatus = label => label.substr(NETLIFY_CMS_LABEL_PREFIX.length);

exports.labelToStatus = labelToStatus;

const statusToLabel = status => "".concat(NETLIFY_CMS_LABEL_PREFIX).concat(status);

exports.statusToLabel = statusToLabel;

const generateContentKey = (collectionName, slug) => "".concat(collectionName, "/").concat(slug);

exports.generateContentKey = generateContentKey;

const parseContentKey = contentKey => {
  const index = contentKey.indexOf('/');
  return {
    collection: contentKey.substr(0, index),
    slug: contentKey.substr(index + 1)
  };
};

exports.parseContentKey = parseContentKey;

const contentKeyFromBranch = branch => {
  return branch.substring("".concat(CMS_BRANCH_PREFIX, "/").length);
};

exports.contentKeyFromBranch = contentKeyFromBranch;

const branchFromContentKey = contentKey => {
  return "".concat(CMS_BRANCH_PREFIX, "/").concat(contentKey);
};

exports.branchFromContentKey = branchFromContentKey;

const readFile = async (id, fetchContent, localForage, isText) => {
  const key = id ? isText ? "gh.".concat(id) : "gh.".concat(id, ".blob") : null;
  const cached = key ? await localForage.getItem(key) : null;

  if (cached) {
    return cached;
  }

  const content = await fetchContent();

  if (key) {
    await localForage.setItem(key, content);
  }

  return content;
};
/**
 * Keywords for inferring a status that will provide a deploy preview URL.
 */


exports.readFile = readFile;
const PREVIEW_CONTEXT_KEYWORDS = ['deploy'];
/**
 * Check a given status context string to determine if it provides a link to a
 * deploy preview. Checks for an exact match against `previewContext` if given,
 * otherwise checks for inclusion of a value from `PREVIEW_CONTEXT_KEYWORDS`.
 */

const isPreviewContext = (context, previewContext) => {
  if (previewContext) {
    return context === previewContext;
  }

  return PREVIEW_CONTEXT_KEYWORDS.some(keyword => context.includes(keyword));
};

exports.isPreviewContext = isPreviewContext;
let PreviewState;
/**
 * Retrieve a deploy preview URL from an array of statuses. By default, a
 * matching status is inferred via `isPreviewContext`.
 */

exports.PreviewState = PreviewState;

(function (PreviewState) {
  PreviewState["Other"] = "other";
  PreviewState["Success"] = "success";
})(PreviewState || (exports.PreviewState = PreviewState = {}));

const getPreviewStatus = (statuses, previewContext) => {
  return statuses.find(({
    context
  }) => {
    return isPreviewContext(context, previewContext);
  });
};

exports.getPreviewStatus = getPreviewStatus;