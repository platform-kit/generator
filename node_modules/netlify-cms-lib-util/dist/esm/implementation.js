"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.runWithLock = exports.getMediaDisplayURL = exports.getMediaAsBlob = exports.blobToFileObj = exports.unpublishedEntries = exports.entriesByFiles = exports.entriesByFolder = void 0;

var _semaphore = _interopRequireDefault(require("semaphore"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MAX_CONCURRENT_DOWNLOADS = 10;

const fetchFiles = async (files, readFile, apiName) => {
  const sem = (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
  const promises = [];
  files.forEach(file => {
    promises.push(new Promise(resolve => sem.take(() => readFile(file.path, file.id, {
      parseText: true
    }).then(data => {
      resolve({
        file,
        data: data
      });
      sem.leave();
    }).catch((error = true) => {
      sem.leave();
      console.error("failed to load file from ".concat(apiName, ": ").concat(file.path));
      resolve({
        error
      });
    }))));
  });
  return Promise.all(promises).then(loadedEntries => loadedEntries.filter(loadedEntry => !loadedEntry.error));
};

const fetchUnpublishedFiles = async (keys, readUnpublishedFile, apiName) => {
  const sem = (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
  const promises = [];
  keys.forEach(key => {
    promises.push(new Promise(resolve => sem.take(() => readUnpublishedFile(key).then(data => {
      if (data === null || data === undefined) {
        resolve({
          error: true
        });
        sem.leave();
      } else {
        resolve({
          slug: data.slug,
          file: {
            path: data.metaData.objects.entry.path,
            id: null
          },
          data: data.fileData,
          metaData: data.metaData,
          isModification: data.isModification
        });
        sem.leave();
      }
    }).catch((error = true) => {
      sem.leave();
      console.error("failed to load file from ".concat(apiName, ": ").concat(key));
      resolve({
        error
      });
    }))));
  });
  return Promise.all(promises).then(loadedEntries => loadedEntries.filter(loadedEntry => !loadedEntry.error));
};

const entriesByFolder = async (listFiles, readFile, apiName) => {
  const files = await listFiles();
  return fetchFiles(files, readFile, apiName);
};

exports.entriesByFolder = entriesByFolder;

const entriesByFiles = async (files, readFile, apiName) => {
  return fetchFiles(files, readFile, apiName);
};

exports.entriesByFiles = entriesByFiles;

const unpublishedEntries = async (listEntriesKeys, readUnpublishedFile, apiName) => {
  try {
    const keys = await listEntriesKeys();
    const entries = await fetchUnpublishedFiles(keys, readUnpublishedFile, apiName);
    return entries;
  } catch (error) {
    if (error.message === 'Not Found') {
      return Promise.resolve([]);
    }

    throw error;
  }
};

exports.unpublishedEntries = unpublishedEntries;

const blobToFileObj = (name, blob) => {
  const options = name.match(/.svg$/) ? {
    type: 'image/svg+xml'
  } : {};
  return new File([blob], name, options);
};

exports.blobToFileObj = blobToFileObj;

const getMediaAsBlob = async (path, id, readFile) => {
  let blob;

  if (path.match(/.svg$/)) {
    const text = await readFile(path, id, {
      parseText: true
    });
    blob = new Blob([text], {
      type: 'image/svg+xml'
    });
  } else {
    blob = await readFile(path, id, {
      parseText: false
    });
  }

  return blob;
};

exports.getMediaAsBlob = getMediaAsBlob;

const getMediaDisplayURL = async (displayURL, readFile, semaphore) => {
  const {
    path,
    id
  } = displayURL;
  return new Promise((resolve, reject) => semaphore.take(() => getMediaAsBlob(path, id, readFile).then(blob => URL.createObjectURL(blob)).then(resolve, reject).finally(() => semaphore.leave())));
};

exports.getMediaDisplayURL = getMediaDisplayURL;

const runWithLock = async (lock, func, message) => {
  try {
    const acquired = await lock.acquire();

    if (!acquired) {
      console.warn(message);
    }

    const result = await func();
    return result;
  } finally {
    lock.release();
  }
};

exports.runWithLock = runWithLock;