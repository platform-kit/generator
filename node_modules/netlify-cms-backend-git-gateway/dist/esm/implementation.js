"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _intersection2 = _interopRequireDefault(require("lodash/intersection"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _gotrueJs = _interopRequireDefault(require("gotrue-js"));

var _jwtDecode = _interopRequireDefault(require("jwt-decode"));

var _ini = _interopRequireDefault(require("ini"));

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _netlifyCmsBackendGithub = require("netlify-cms-backend-github");

var _netlifyCmsBackendGitlab = require("netlify-cms-backend-gitlab");

var _netlifyCmsBackendBitbucket = require("netlify-cms-backend-bitbucket");

var _GitHubAPI = _interopRequireDefault(require("./GitHubAPI"));

var _GitLabAPI = _interopRequireDefault(require("./GitLabAPI"));

var _AuthenticationPage = _interopRequireDefault(require("./AuthenticationPage"));

var _netlifyLfsClient = require("./netlify-lfs-client");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const localHosts = {
  localhost: true,
  '127.0.0.1': true,
  '0.0.0.0': true
};
const defaults = {
  identity: '/.netlify/identity',
  gateway: '/.netlify/git',
  largeMedia: '/.netlify/large-media'
};

function getEndpoint(endpoint, netlifySiteURL) {
  if (localHosts[document.location.host.split(':').shift()] && netlifySiteURL && endpoint.match(/^\/\.netlify\//)) {
    const parts = [];

    if (netlifySiteURL) {
      parts.push(netlifySiteURL);

      if (!netlifySiteURL.match(/\/$/)) {
        parts.push('/');
      }
    }

    parts.push(endpoint.replace(/^\//, ''));
    return parts.join('');
  }

  return endpoint;
}

class GitGateway {
  constructor(config, options = {}) {
    var _config$backend$branc;

    _defineProperty(this, "config", void 0);

    _defineProperty(this, "api", void 0);

    _defineProperty(this, "branch", void 0);

    _defineProperty(this, "squashMerges", void 0);

    _defineProperty(this, "mediaFolder", void 0);

    _defineProperty(this, "transformImages", void 0);

    _defineProperty(this, "gatewayUrl", void 0);

    _defineProperty(this, "netlifyLargeMediaURL", void 0);

    _defineProperty(this, "backendType", void 0);

    _defineProperty(this, "authClient", void 0);

    _defineProperty(this, "backend", void 0);

    _defineProperty(this, "acceptRoles", void 0);

    _defineProperty(this, "tokenPromise", void 0);

    _defineProperty(this, "_largeMediaClientPromise", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "requestFunction", req => this.tokenPromise().then(token => _netlifyCmsLibUtil.unsentRequest.withHeaders({
      Authorization: "Bearer ".concat(token)
    }, req)).then(_netlifyCmsLibUtil.unsentRequest.performRequest));

    this.options = _objectSpread({
      proxied: true,
      API: null,
      initialWorkflowStatus: ''
    }, options);
    this.config = config;
    this.branch = ((_config$backend$branc = config.backend.branch) === null || _config$backend$branc === void 0 ? void 0 : _config$backend$branc.trim()) || 'master';
    this.squashMerges = config.backend.squash_merges || false;
    this.mediaFolder = config.media_folder;
    this.transformImages = config.backend.use_large_media_transforms_in_media_library || true;
    const netlifySiteURL = localStorage.getItem('netlifySiteURL');
    const APIUrl = getEndpoint(config.backend.identity_url || defaults.identity, netlifySiteURL);
    this.gatewayUrl = getEndpoint(config.backend.gateway_url || defaults.gateway, netlifySiteURL);
    this.netlifyLargeMediaURL = getEndpoint(config.backend.large_media_url || defaults.largeMedia, netlifySiteURL);
    const backendTypeRegex = /\/(github|gitlab|bitbucket)\/?$/;
    const backendTypeMatches = this.gatewayUrl.match(backendTypeRegex);

    if (backendTypeMatches) {
      this.backendType = backendTypeMatches[1];
      this.gatewayUrl = this.gatewayUrl.replace(backendTypeRegex, '');
    } else {
      this.backendType = null;
    }

    this.authClient = window.netlifyIdentity ? window.netlifyIdentity.gotrue : new _gotrueJs.default({
      APIUrl
    });
    _AuthenticationPage.default.authClient = this.authClient;
    this.backend = null;
  }

  authenticate(credentials) {
    const user = credentials;
    this.tokenPromise = user.jwt.bind(user);
    return this.tokenPromise().then(async token => {
      if (!this.backendType) {
        const {
          github_enabled: githubEnabled,
          gitlab_enabled: gitlabEnabled,
          bitbucket_enabled: bitbucketEnabled,
          roles
        } = await fetch("".concat(this.gatewayUrl, "/settings"), {
          headers: {
            Authorization: "Bearer ".concat(token)
          }
        }).then(async res => {
          const contentType = res.headers.get('Content-Type') || '';

          if (!contentType.includes('application/json') && !contentType.includes('text/json')) {
            throw new _netlifyCmsLibUtil.APIError("Your Git Gateway backend is not returning valid settings. Please make sure it is enabled.", res.status, 'Git Gateway');
          }

          const body = await res.json();

          if (!res.ok) {
            throw new _netlifyCmsLibUtil.APIError("Git Gateway Error: ".concat(body.message ? body.message : body), res.status, 'Git Gateway');
          }

          return body;
        });
        this.acceptRoles = roles;

        if (githubEnabled) {
          this.backendType = 'github';
        } else if (gitlabEnabled) {
          this.backendType = 'gitlab';
        } else if (bitbucketEnabled) {
          this.backendType = 'bitbucket';
        }
      }

      if (this.acceptRoles && this.acceptRoles.length > 0) {
        const userRoles = (0, _get2.default)((0, _jwtDecode.default)(token), 'app_metadata.roles', []);
        const validRole = (0, _intersection2.default)(userRoles, this.acceptRoles).length > 0;

        if (!validRole) {
          throw new Error("You don't have sufficient permissions to access Netlify CMS");
        }
      }

      const userData = {
        name: user.user_metadata.full_name || user.email.split('@').shift(),
        email: user.email,
        // eslint-disable-next-line @typescript-eslint/camelcase
        avatar_url: user.user_metadata.avatar_url,
        metadata: user.user_metadata
      };
      const apiConfig = {
        apiRoot: "".concat(this.gatewayUrl, "/").concat(this.backendType),
        branch: this.branch,
        tokenPromise: this.tokenPromise,
        commitAuthor: (0, _pick2.default)(userData, ['name', 'email']),
        squashMerges: this.squashMerges,
        initialWorkflowStatus: this.options.initialWorkflowStatus
      };

      if (this.backendType === 'github') {
        this.api = new _GitHubAPI.default(apiConfig);
        this.backend = new _netlifyCmsBackendGithub.GitHubBackend(this.config, _objectSpread({}, this.options, {
          API: this.api
        }));
      } else if (this.backendType === 'gitlab') {
        this.api = new _GitLabAPI.default(apiConfig);
        this.backend = new _netlifyCmsBackendGitlab.GitLabBackend(this.config, _objectSpread({}, this.options, {
          API: this.api
        }));
      } else if (this.backendType === 'bitbucket') {
        this.api = new _netlifyCmsBackendBitbucket.API(_objectSpread({}, apiConfig, {
          requestFunction: this.requestFunction,
          hasWriteAccess: async () => true
        }));
        this.backend = new _netlifyCmsBackendBitbucket.BitbucketBackend(this.config, _objectSpread({}, this.options, {
          API: this.api
        }));
      }

      if (!(await this.api.hasWriteAccess())) {
        throw new Error("You don't have sufficient permissions to access Netlify CMS");
      }

      return {
        name: userData.name,
        login: userData.email
      };
    });
  }

  restoreUser() {
    const user = this.authClient && this.authClient.currentUser();
    if (!user) return Promise.reject();
    return this.authenticate(user);
  }

  authComponent() {
    return _AuthenticationPage.default;
  }

  logout() {
    if (window.netlifyIdentity) {
      return window.netlifyIdentity.logout();
    }

    const user = this.authClient.currentUser();
    return user && user.logout();
  }

  getToken() {
    return this.tokenPromise();
  }

  entriesByFolder(folder, extension, depth) {
    return this.backend.entriesByFolder(folder, extension, depth);
  }

  allEntriesByFolder(folder, extension, depth) {
    return this.backend.allEntriesByFolder(folder, extension, depth);
  }

  entriesByFiles(files) {
    return this.backend.entriesByFiles(files);
  }

  getEntry(path) {
    return this.backend.getEntry(path);
  }

  async loadEntryMediaFiles(branch, files) {
    const client = await this.getLargeMediaClient();
    const backend = this.backend;

    if (!client.enabled) {
      return backend.loadEntryMediaFiles(branch, files);
    }

    const mediaFiles = await Promise.all(files.map(async file => {
      if (client.matchPath(file.path)) {
        const {
          path,
          id
        } = file;
        const url = await this.getLargeMediaDisplayURL({
          path,
          id
        }, branch);
        return {
          id,
          name: (0, _netlifyCmsLibUtil.basename)(path),
          path,
          url,
          displayURL: url,
          file: new File([], name),
          size: 0
        };
      } else {
        return backend.loadMediaFile(branch, file);
      }
    }));
    return mediaFiles;
  }

  getMedia(mediaFolder = this.mediaFolder) {
    return this.backend.getMedia(mediaFolder);
  } // this method memoizes this._getLargeMediaClient so that there can
  // only be one client at a time


  getLargeMediaClient() {
    if (this._largeMediaClientPromise) {
      return this._largeMediaClientPromise;
    }

    this._largeMediaClientPromise = this._getLargeMediaClient();
    return this._largeMediaClientPromise;
  }

  _getLargeMediaClient() {
    const netlifyLargeMediaEnabledPromise = this.api.readFile('.lfsconfig').then(config => _ini.default.decode(config)).then(({
      lfs: {
        url
      }
    }) => new URL(url)).then(lfsURL => ({
      enabled: lfsURL.hostname.endsWith('netlify.com')
    })).catch(err => ({
      enabled: false,
      err
    }));
    const lfsPatternsPromise = this.api.readFile('.gitattributes').then(attributes => (0, _netlifyCmsLibUtil.getLargeMediaPatternsFromGitAttributesFile)(attributes)).then(patterns => ({
      err: null,
      patterns
    })).catch(err => {
      if (err.message.includes('404')) {
        console.log('This 404 was expected and handled appropriately.');
        return {
          err: null,
          patterns: []
        };
      } else {
        return {
          err,
          patterns: []
        };
      }
    });
    return Promise.all([netlifyLargeMediaEnabledPromise, lfsPatternsPromise]).then(([{
      enabled: maybeEnabled
    }, {
      patterns,
      err: patternsErr
    }]) => {
      const enabled = maybeEnabled && !patternsErr; // We expect LFS patterns to exist when the .lfsconfig states
      // that we're using Netlify Large Media

      if (maybeEnabled && patternsErr) {
        console.error(patternsErr);
      }

      return (0, _netlifyLfsClient.getClient)({
        enabled,
        rootURL: this.netlifyLargeMediaURL,
        makeAuthorizedRequest: this.requestFunction,
        patterns,
        transformImages: this.transformImages ? // eslint-disable-next-line @typescript-eslint/camelcase
        {
          nf_resize: 'fit',
          w: 560,
          h: 320
        } : false
      });
    });
  }

  async getLargeMediaDisplayURL({
    path,
    id
  }, branch = this.branch) {
    const readFile = (path, id, {
      parseText
    }) => this.api.readFile(path, id, {
      branch,
      parseText
    });

    const items = await (0, _netlifyCmsLibUtil.entriesByFiles)([{
      path,
      id
    }], readFile, 'Git-Gateway');
    const entry = items[0];
    const pointerFile = (0, _netlifyCmsLibUtil.parsePointerFile)(entry.data);

    if (!pointerFile.sha) {
      console.warn("Failed parsing pointer file ".concat(path));
      return path;
    }

    const client = await this.getLargeMediaClient();
    const url = await client.getDownloadURL(pointerFile);
    return url;
  }

  async getMediaDisplayURL(displayURL) {
    const {
      path,
      id
    } = displayURL;
    const client = await this.getLargeMediaClient();

    if (client.enabled && client.matchPath(path)) {
      return this.getLargeMediaDisplayURL({
        path,
        id
      });
    }

    if (typeof displayURL === 'string') {
      return displayURL;
    }

    if (this.backend.getMediaDisplayURL) {
      return this.backend.getMediaDisplayURL(displayURL);
    }

    const err = new Error("getMediaDisplayURL is not implemented by the ".concat(this.backendType, " backend, but the backend returned a displayURL which was not a string!"));
    err.displayURL = displayURL;
    return Promise.reject(err);
  }

  async getMediaFile(path) {
    const client = await this.getLargeMediaClient();

    if (client.enabled && client.matchPath(path)) {
      const url = await this.getLargeMediaDisplayURL({
        path,
        id: null
      });
      return {
        id: url,
        name: (0, _netlifyCmsLibUtil.basename)(path),
        path,
        url,
        displayURL: url
      };
    }

    return this.backend.getMediaFile(path);
  }

  async persistEntry(entry, mediaFiles, options) {
    const client = await this.getLargeMediaClient();
    return this.backend.persistEntry(entry, client.enabled ? await (0, _netlifyCmsLibUtil.getLargeMediaFilteredMediaFiles)(client, mediaFiles) : mediaFiles, options);
  }

  async persistMedia(mediaFile, options) {
    const {
      fileObj,
      path
    } = mediaFile;
    const displayURL = URL.createObjectURL(fileObj);
    const client = await this.getLargeMediaClient();
    const fixedPath = path.startsWith('/') ? path.slice(1) : path;

    if (!client.enabled || !client.matchPath(fixedPath)) {
      return this.backend.persistMedia(mediaFile, options);
    }

    const persistMediaArgument = await (0, _netlifyCmsLibUtil.getPointerFileForMediaFileObj)(client, fileObj, path);
    return _objectSpread({}, (await this.backend.persistMedia(persistMediaArgument, options)), {
      displayURL
    });
  }

  deleteFile(path, commitMessage) {
    return this.backend.deleteFile(path, commitMessage);
  }

  async getDeployPreview(collection, slug) {
    return this.backend.getDeployPreview(collection, slug);
  }

  unpublishedEntries() {
    return this.backend.unpublishedEntries();
  }

  unpublishedEntry(collection, slug) {
    return this.backend.unpublishedEntry(collection, slug, {
      loadEntryMediaFiles: (branch, files) => this.loadEntryMediaFiles(branch, files)
    });
  }

  updateUnpublishedEntryStatus(collection, slug, newStatus) {
    return this.backend.updateUnpublishedEntryStatus(collection, slug, newStatus);
  }

  deleteUnpublishedEntry(collection, slug) {
    return this.backend.deleteUnpublishedEntry(collection, slug);
  }

  publishUnpublishedEntry(collection, slug) {
    return this.backend.publishUnpublishedEntry(collection, slug);
  }

  traverseCursor(cursor, action) {
    return this.backend.traverseCursor(cursor, action);
  }

}

exports.default = GitGateway;