"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _trimStart2 = _interopRequireDefault(require("lodash/trimStart"));

var _flow2 = _interopRequireDefault(require("lodash/flow"));

var _semaphore = _interopRequireDefault(require("semaphore"));

var _commonTags = require("common-tags");

var _netlifyCmsLibUtil = require("netlify-cms-lib-util");

var _netlifyCmsLibAuth = _interopRequireDefault(require("netlify-cms-lib-auth"));

var _AuthenticationPage = _interopRequireDefault(require("./AuthenticationPage"));

var _API = _interopRequireWildcard(require("./API"));

var _gitLfsClient = require("./git-lfs-client");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _templateObject() {
  const data = _taggedTemplateLiteral(["\n        Repo \"", "\" not found.\n\n        Please ensure the repo information is spelled correctly.\n\n        If the repo is private, make sure you're logged into a Bitbucket account with access.\n      "]);

  _templateObject = function () {
    return data;
  };

  return data;
}

function _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const MAX_CONCURRENT_DOWNLOADS = 10; // Implementation wrapper class

class BitbucketBackend {
  constructor(config, options = {}) {
    _defineProperty(this, "lock", void 0);

    _defineProperty(this, "api", void 0);

    _defineProperty(this, "updateUserCredentials", void 0);

    _defineProperty(this, "options", void 0);

    _defineProperty(this, "repo", void 0);

    _defineProperty(this, "branch", void 0);

    _defineProperty(this, "apiRoot", void 0);

    _defineProperty(this, "baseUrl", void 0);

    _defineProperty(this, "siteId", void 0);

    _defineProperty(this, "token", void 0);

    _defineProperty(this, "mediaFolder", void 0);

    _defineProperty(this, "refreshToken", void 0);

    _defineProperty(this, "refreshedTokenPromise", void 0);

    _defineProperty(this, "authenticator", void 0);

    _defineProperty(this, "auth", void 0);

    _defineProperty(this, "_mediaDisplayURLSem", void 0);

    _defineProperty(this, "squashMerges", void 0);

    _defineProperty(this, "previewContext", void 0);

    _defineProperty(this, "largeMediaURL", void 0);

    _defineProperty(this, "_largeMediaClientPromise", void 0);

    _defineProperty(this, "requestFunction", req => this.getToken().then(token => _netlifyCmsLibUtil.unsentRequest.withHeaders({
      Authorization: "Bearer ".concat(token)
    }, req)).then(_netlifyCmsLibUtil.unsentRequest.performRequest));

    _defineProperty(this, "apiRequestFunction", async req => {
      const token = this.refreshedTokenPromise ? await this.refreshedTokenPromise : this.token;
      return (0, _flow2.default)([_netlifyCmsLibUtil.unsentRequest.withHeaders({
        Authorization: "Bearer ".concat(token)
      }), _netlifyCmsLibUtil.unsentRequest.performRequest, (0, _netlifyCmsLibUtil.then)(async res => {
        if (res.status === 401) {
          const json = await res.json().catch(() => null);

          if (json && json.type === 'error' && /^access token expired/i.test(json.error.message)) {
            const newToken = await this.getRefreshedAccessToken();

            const reqWithNewToken = _netlifyCmsLibUtil.unsentRequest.withHeaders({
              Authorization: "Bearer ".concat(newToken)
            }, req);

            return _netlifyCmsLibUtil.unsentRequest.performRequest(reqWithNewToken);
          }
        }

        return res;
      })])(req);
    });

    this.options = _objectSpread({
      proxied: false,
      API: null,
      updateUserCredentials: async () => null,
      initialWorkflowStatus: ''
    }, options);

    if (!this.options.proxied && (config.backend.repo === null || config.backend.repo === undefined)) {
      throw new Error('The BitBucket backend needs a "repo" in the backend configuration.');
    }

    this.api = this.options.API || null;
    this.updateUserCredentials = this.options.updateUserCredentials;
    this.repo = config.backend.repo || '';
    this.branch = config.backend.branch || 'master';
    this.apiRoot = config.backend.api_root || 'https://api.bitbucket.org/2.0';
    this.baseUrl = config.base_url || '';
    this.siteId = config.site_id || '';
    this.largeMediaURL = config.backend.large_media_url || "https://bitbucket.org/".concat(config.backend.repo, "/info/lfs");
    this.token = '';
    this.mediaFolder = config.media_folder;
    this.squashMerges = config.backend.squash_merges || false;
    this.previewContext = config.backend.preview_context || '';
    this.lock = (0, _netlifyCmsLibUtil.asyncLock)();
  }

  authComponent() {
    return _AuthenticationPage.default;
  }

  setUser(user) {
    this.token = user.token;
    this.api = new _API.default({
      requestFunction: this.apiRequestFunction,
      branch: this.branch,
      repo: this.repo,
      squashMerges: this.squashMerges,
      initialWorkflowStatus: this.options.initialWorkflowStatus
    });
  }

  restoreUser(user) {
    return this.authenticate(user);
  }

  async authenticate(state) {
    this.token = state.token;
    this.refreshToken = state.refresh_token;
    this.api = new _API.default({
      requestFunction: this.apiRequestFunction,
      branch: this.branch,
      repo: this.repo,
      apiRoot: this.apiRoot,
      squashMerges: this.squashMerges,
      initialWorkflowStatus: this.options.initialWorkflowStatus
    });
    const isCollab = await this.api.hasWriteAccess().catch(error => {
      error.message = (0, _commonTags.stripIndent)(_templateObject(), this.repo);
      throw error;
    }); // Unauthorized user

    if (!isCollab) {
      throw new Error('Your BitBucket user account does not have access to this repo.');
    }

    const user = await this.api.user(); // Authorized user

    return _objectSpread({}, user, {
      name: user.display_name,
      login: user.username,
      token: state.token,
      // eslint-disable-next-line @typescript-eslint/camelcase
      avatar_url: user.links.avatar.href,
      // eslint-disable-next-line @typescript-eslint/camelcase
      refresh_token: state.refresh_token
    });
  }

  getRefreshedAccessToken() {
    if (this.refreshedTokenPromise) {
      return this.refreshedTokenPromise;
    } // instantiating a new Authenticator on each refresh isn't ideal,


    if (!this.auth) {
      const cfg = {
        // eslint-disable-next-line @typescript-eslint/camelcase
        base_url: this.baseUrl,
        // eslint-disable-next-line @typescript-eslint/camelcase
        site_id: this.siteId
      };
      this.authenticator = new _netlifyCmsLibAuth.default(cfg);
    }

    this.refreshedTokenPromise = this.authenticator // eslint-disable-next-line @typescript-eslint/camelcase
    .refresh({
      provider: 'bitbucket',
      refresh_token: this.refreshToken
    }) // eslint-disable-next-line @typescript-eslint/camelcase
    .then(({
      token,
      refresh_token
    }) => {
      this.token = token; // eslint-disable-next-line @typescript-eslint/camelcase

      this.refreshToken = refresh_token;
      this.refreshedTokenPromise = undefined; // eslint-disable-next-line @typescript-eslint/camelcase

      this.updateUserCredentials({
        token,
        refresh_token
      });
      return token;
    });
    return this.refreshedTokenPromise;
  }

  logout() {
    this.token = null;
    return;
  }

  getToken() {
    if (this.refreshedTokenPromise) {
      return this.refreshedTokenPromise;
    }

    return Promise.resolve(this.token);
  }

  async entriesByFolder(folder, extension, depth) {
    let cursor;

    const listFiles = () => this.api.listFiles(folder, depth).then(({
      entries,
      cursor: c
    }) => {
      cursor = c.mergeMeta({
        extension
      });
      return (0, _netlifyCmsLibUtil.filterByPropExtension)(extension, 'path')(entries);
    });

    const files = await (0, _netlifyCmsLibUtil.entriesByFolder)(listFiles, this.api.readFile.bind(this.api), 'BitBucket'); // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore

    files[_netlifyCmsLibUtil.CURSOR_COMPATIBILITY_SYMBOL] = cursor;
    return files;
  }

  async allEntriesByFolder(folder, extension, depth) {
    const listFiles = () => this.api.listAllFiles(folder, depth).then((0, _netlifyCmsLibUtil.filterByPropExtension)(extension, 'path'));

    const files = await (0, _netlifyCmsLibUtil.entriesByFolder)(listFiles, this.api.readFile.bind(this.api), 'BitBucket');
    return files;
  }

  async entriesByFiles(files) {
    return (0, _netlifyCmsLibUtil.entriesByFiles)(files, this.api.readFile.bind(this.api), 'BitBucket');
  }

  getEntry(path) {
    return this.api.readFile(path).then(data => ({
      file: {
        path,
        id: null
      },
      data: data
    }));
  }

  getMedia(mediaFolder = this.mediaFolder) {
    return this.api.listAllFiles(mediaFolder).then(files => files.map(({
      id,
      name,
      path
    }) => ({
      id,
      name,
      path,
      displayURL: {
        id,
        path
      }
    })));
  }

  getLargeMediaClient() {
    if (!this._largeMediaClientPromise) {
      this._largeMediaClientPromise = (async () => {
        const patterns = await this.api.readFile('.gitattributes').then(attributes => (0, _netlifyCmsLibUtil.getLargeMediaPatternsFromGitAttributesFile)(attributes)).catch(err => {
          if (err.status === 404) {
            console.log('This 404 was expected and handled appropriately.');
          } else {
            console.error(err);
          }

          return [];
        });
        return new _gitLfsClient.GitLfsClient(!!(this.largeMediaURL && patterns.length > 0), this.largeMediaURL, patterns, this.requestFunction);
      })();
    }

    return this._largeMediaClientPromise;
  }

  getMediaDisplayURL(displayURL) {
    this._mediaDisplayURLSem = this._mediaDisplayURLSem || (0, _semaphore.default)(MAX_CONCURRENT_DOWNLOADS);
    return (0, _netlifyCmsLibUtil.getMediaDisplayURL)(displayURL, this.api.readFile.bind(this.api), this._mediaDisplayURLSem);
  }

  async getMediaFile(path) {
    const name = (0, _netlifyCmsLibUtil.basename)(path);
    const blob = await (0, _netlifyCmsLibUtil.getMediaAsBlob)(path, null, this.api.readFile.bind(this.api));
    const fileObj = (0, _netlifyCmsLibUtil.blobToFileObj)(name, blob);
    const url = URL.createObjectURL(fileObj);
    const id = await (0, _netlifyCmsLibUtil.getBlobSHA)(fileObj);
    return {
      id,
      displayURL: url,
      path,
      name,
      size: fileObj.size,
      file: fileObj,
      url
    };
  }

  async persistEntry(entry, mediaFiles, options) {
    const client = await this.getLargeMediaClient(); // persistEntry is a transactional operation

    return (0, _netlifyCmsLibUtil.runWithLock)(this.lock, async () => this.api.persistFiles(entry, client.enabled ? await (0, _netlifyCmsLibUtil.getLargeMediaFilteredMediaFiles)(client, mediaFiles) : mediaFiles, options), 'Failed to acquire persist entry lock');
  }

  async persistMedia(mediaFile, options) {
    const {
      fileObj,
      path
    } = mediaFile;
    const displayURL = URL.createObjectURL(fileObj);
    const client = await this.getLargeMediaClient();
    const fixedPath = path.startsWith('/') ? path.slice(1) : path;

    if (!client.enabled || !client.matchPath(fixedPath)) {
      return this._persistMedia(mediaFile, options);
    }

    const persistMediaArgument = await (0, _netlifyCmsLibUtil.getPointerFileForMediaFileObj)(client, fileObj, path);
    return _objectSpread({}, (await this._persistMedia(persistMediaArgument, options)), {
      displayURL
    });
  }

  async _persistMedia(mediaFile, options) {
    const fileObj = mediaFile.fileObj;
    const [id] = await Promise.all([(0, _netlifyCmsLibUtil.getBlobSHA)(fileObj), this.api.persistFiles(null, [mediaFile], options)]);
    const url = URL.createObjectURL(fileObj);
    return {
      displayURL: url,
      path: (0, _trimStart2.default)(mediaFile.path, '/k'),
      name: fileObj.name,
      size: fileObj.size,
      id,
      file: fileObj,
      url
    };
  }

  deleteFile(path, commitMessage) {
    return this.api.deleteFile(path, commitMessage);
  }

  traverseCursor(cursor, action) {
    return this.api.traverseCursor(cursor, action).then(async ({
      entries,
      cursor: newCursor
    }) => {
      var _cursor$meta;

      const extension = (_cursor$meta = cursor.meta) === null || _cursor$meta === void 0 ? void 0 : _cursor$meta.get('extension');

      if (extension) {
        entries = (0, _netlifyCmsLibUtil.filterByPropExtension)(extension, 'path')(entries);
        newCursor = newCursor.mergeMeta({
          extension
        });
      }

      return {
        entries: await Promise.all(entries.map(file => this.api.readFile(file.path, file.id).then(data => ({
          file,
          data: data
        })))),
        cursor: newCursor
      };
    });
  }

  loadMediaFile(branch, file) {
    const readFile = (path, id, {
      parseText
    }) => this.api.readFile(path, id, {
      branch,
      parseText
    });

    return (0, _netlifyCmsLibUtil.getMediaAsBlob)(file.path, null, readFile).then(blob => {
      const name = (0, _netlifyCmsLibUtil.basename)(file.path);
      const fileObj = (0, _netlifyCmsLibUtil.blobToFileObj)(name, blob);
      return {
        id: file.path,
        displayURL: URL.createObjectURL(fileObj),
        path: file.path,
        name,
        size: fileObj.size,
        file: fileObj
      };
    });
  }

  async loadEntryMediaFiles(branch, files) {
    const mediaFiles = await Promise.all(files.map(file => this.loadMediaFile(branch, file)));
    return mediaFiles;
  }

  async unpublishedEntries() {
    const listEntriesKeys = () => this.api.listUnpublishedBranches().then(branches => branches.map(branch => (0, _netlifyCmsLibUtil.contentKeyFromBranch)(branch)));

    const readUnpublishedBranchFile = contentKey => this.api.readUnpublishedBranchFile(contentKey);

    return (0, _netlifyCmsLibUtil.unpublishedEntries)(listEntriesKeys, readUnpublishedBranchFile, _API.API_NAME);
  }

  async unpublishedEntry(collection, slug, {
    loadEntryMediaFiles = (branch, files) => this.loadEntryMediaFiles(branch, files)
  } = {}) {
    const contentKey = (0, _netlifyCmsLibUtil.generateContentKey)(collection, slug);
    const data = await this.api.readUnpublishedBranchFile(contentKey);
    const mediaFiles = await loadEntryMediaFiles(data.metaData.branch, // TODO: fix this
    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore
    data.metaData.objects.entry.mediaFiles);
    return {
      slug,
      file: {
        path: data.metaData.objects.entry.path,
        id: null
      },
      data: data.fileData,
      metaData: data.metaData,
      mediaFiles,
      isModification: data.isModification
    };
  }

  async updateUnpublishedEntryStatus(collection, slug, newStatus) {
    // updateUnpublishedEntryStatus is a transactional operation
    return (0, _netlifyCmsLibUtil.runWithLock)(this.lock, () => this.api.updateUnpublishedEntryStatus(collection, slug, newStatus), 'Failed to acquire update entry status lock');
  }

  async deleteUnpublishedEntry(collection, slug) {
    // deleteUnpublishedEntry is a transactional operation
    return (0, _netlifyCmsLibUtil.runWithLock)(this.lock, () => this.api.deleteUnpublishedEntry(collection, slug), 'Failed to acquire delete entry lock');
  }

  async publishUnpublishedEntry(collection, slug) {
    // publishUnpublishedEntry is a transactional operation
    return (0, _netlifyCmsLibUtil.runWithLock)(this.lock, () => this.api.publishUnpublishedEntry(collection, slug), 'Failed to acquire publish entry lock');
  }

  async getDeployPreview(collection, slug) {
    try {
      const statuses = await this.api.getStatuses(collection, slug);
      const deployStatus = (0, _netlifyCmsLibUtil.getPreviewStatus)(statuses, this.previewContext);

      if (deployStatus) {
        const {
          target_url: url,
          state
        } = deployStatus;
        return {
          url,
          status: state
        };
      } else {
        return null;
      }
    } catch (e) {
      return null;
    }
  }

}

exports.default = BitbucketBackend;