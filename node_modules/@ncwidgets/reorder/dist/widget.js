"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const immutable_1 = require("immutable");
const utils_1 = require("./utils");
const preview_1 = require("./preview");
const control_1 = require("./control");
const createControl = ({ renderControl, renderPreview, previewRef }) => {
    return class Control extends React.Component {
        constructor() {
            super(...arguments);
            this.state = {
                data: {},
                fetched: false,
                newOrder: [],
                modified: 'none'
            };
            this.handleDisplayChange = () => {
                const { newOrder } = this.state;
                const { onChange } = this.props;
                this.setState({ modified: 'none' }, () => {
                    onChange(immutable_1.fromJS(newOrder));
                });
            };
            this.handleDragEnd = (result) => {
                if (!result.destination ||
                    result.source.index === result.destination.index)
                    return;
                const { value, onChange } = this.props;
                const data = value.toJS();
                const sortedData = utils_1.reorder({
                    data,
                    startIndex: result.source.index,
                    endIndex: result.destination.index
                });
                onChange(immutable_1.fromJS(sortedData));
            };
        }
        componentDidMount() {
            return __awaiter(this, void 0, void 0, function* () {
                const { forID, field, value, query } = this.props;
                const collection = field.get('collection');
                const fieldId = field.get('id_field');
                // no value or empty value, assuming value is always a List<string>
                const noValue = (typeof value === 'undefined' || value.size === 0);
                const result = yield query(forID, collection, [fieldId], '');
                const sourceData = result.payload.response.hits.map(payload => payload.data);
                // @ts-ignore
                const normalizedData = utils_1.normalize(sourceData, fieldId);
                this.setState({ data: normalizedData, fetched: true });
                const idData = sourceData.map(item => item[fieldId]);
                if (noValue) {
                    this.setState({ newOrder: idData, modified: 'unset' });
                    return;
                }
                const currentOrder = value.toJS();
                const { newOrder, modified } = utils_1.diff({
                    currentOrder,
                    data: idData,
                });
                if (modified) {
                    this.setState({ newOrder, modified: 'modified' });
                }
            });
        }
        render() {
            const { field, value, classNameWrapper } = this.props;
            const { modified, data, fetched } = this.state;
            const collection = field.get('collection');
            const maxHeight = field.get('max_height', 'none');
            const noValue = (typeof value === 'undefined' || value.size === 0);
            if (!fetched)
                return React.createElement("div", null, "loading...");
            if (fetched && Object.keys(data).length === 0) {
                return (React.createElement(control_1.EmptyMessage, { className: classNameWrapper, collection: collection }));
            }
            return (React.createElement("div", { style: { position: 'relative', minHeight: '12rem' } },
                modified !== 'none' && React.createElement(control_1.Modal, Object.assign({ handleDisplayChange: this.handleDisplayChange }, { collection, modified })),
                !noValue && React.createElement(control_1.ControlList, { onDragEnd: this.handleDragEnd, maxHeight: maxHeight }, value.map((id, i) => {
                    const item = data[id];
                    const value = (typeof item === 'undefined')
                        ? { error: 'Entry does not exist' }
                        // @ts-ignore
                        : item;
                    return (React.createElement(control_1.ControlDraggableItem, { key: id, identifier: id, index: i }, renderControl({ value, field })));
                })),
                React.createElement(preview_1.PreviewPortal, { portalRef: previewRef }, !noValue && renderPreview({
                    value: value.map(identifier => data[identifier])
                }))));
        }
    };
};
exports.createWidget = ({ renderControl = control_1.renderDefaultControl, renderPreview = preview_1.renderDefaultPreview, name = 'ncw-reorder' }) => {
    const previewRef = React.createRef();
    return {
        name,
        controlComponent: createControl({
            renderControl, renderPreview, previewRef,
        }),
        previewComponent: preview_1.createPreview(previewRef),
    };
};
