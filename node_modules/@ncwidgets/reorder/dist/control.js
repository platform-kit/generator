"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importDefault(require("react"));
const react_dom_1 = require("react-dom");
const immutable_1 = require("immutable");
const utils_1 = require("./utils");
const drag_drop_1 = require("./components/drag-drop");
const modal_1 = require("./components/modal");
const utils_2 = require("./utils");
exports.PreviewPortal = ({ portalRef, children }) => portalRef && portalRef.current && react_dom_1.createPortal(children, portalRef.current);
exports.renderDefaultControl = ({ value, field }) => {
    const fieldId = field.get('id_field');
    const template = field.get('display_template', `{{${fieldId}}}`);
    return utils_2.parseTemplate({ template, data: value });
};
exports.createControl = ({ renderControl, renderPreview, previewRef }) => {
    return class Control extends react_1.default.Component {
        constructor() {
            super(...arguments);
            this.state = {
                data: {},
                fetched: false,
                newOrder: [],
                modified: 'none'
            };
            this.handleDisplayChange = () => {
                const { newOrder } = this.state;
                const { onChange } = this.props;
                this.setState({ modified: 'none' }, () => {
                    onChange(immutable_1.fromJS(newOrder));
                });
            };
            this.handleDragEnd = (result) => {
                if (!result.destination ||
                    result.source.index === result.destination.index)
                    return;
                const { value, onChange } = this.props;
                const data = value.toJS();
                const sortedData = utils_1.reorder({
                    data,
                    startIndex: result.source.index,
                    endIndex: result.destination.index
                });
                onChange(immutable_1.fromJS(sortedData));
            };
        }
        componentDidMount() {
            return __awaiter(this, void 0, void 0, function* () {
                const { forID, field, value, query } = this.props;
                const collection = field.get('collection');
                const fieldId = field.get('id_field');
                // no value or empty value, assuming value is always a List<string>
                const noValue = (typeof value === 'undefined' || value.size === 0);
                const result = yield query(forID, collection, [fieldId], '');
                const sourceData = result.payload.response.hits.map(payload => payload.data);
                // @ts-ignore
                const normalizedData = utils_1.normalize(sourceData, fieldId);
                this.setState({ data: normalizedData, fetched: true });
                const idData = sourceData.map(item => item[fieldId]);
                if (noValue) {
                    this.setState({ newOrder: idData, modified: 'unset' });
                    return;
                }
                const currentOrder = value.toJS();
                const { newOrder, modified } = utils_1.diff({
                    currentOrder,
                    data: idData,
                });
                if (modified) {
                    this.setState({ newOrder, modified: 'modified' });
                }
            });
        }
        render() {
            const { field, value, classNameWrapper } = this.props;
            const { modified, data, fetched } = this.state;
            const collection = field.get('collection');
            const maxHeight = field.get('max_height', 'none');
            const noValue = (typeof value === 'undefined' || value.size === 0);
            if (!fetched)
                return react_1.default.createElement("div", null, "loading...");
            if (fetched && Object.keys(data).length === 0) {
                return (react_1.default.createElement(modal_1.EmptyMessage, { className: classNameWrapper, collection: collection }));
            }
            return (react_1.default.createElement("div", { style: { position: 'relative', minHeight: '12rem' } },
                modified !== 'none' && react_1.default.createElement(modal_1.Modal, Object.assign({ handleDisplayChange: this.handleDisplayChange }, { collection, modified })),
                !noValue && react_1.default.createElement(drag_drop_1.ControlList, { onDragEnd: this.handleDragEnd, maxHeight: maxHeight }, value.map((id, i) => {
                    const item = data[id];
                    const value = (typeof item === 'undefined')
                        ? { error: 'Entry does not exist' }
                        // @ts-ignore
                        : item;
                    return (react_1.default.createElement(drag_drop_1.ControlDraggableItem, { key: id, identifier: id, index: i }, renderControl({ value, field })));
                })),
                react_1.default.createElement(exports.PreviewPortal, { portalRef: previewRef }, !noValue && renderPreview({
                    value: value.map(identifier => data[identifier])
                }))));
        }
    };
};
