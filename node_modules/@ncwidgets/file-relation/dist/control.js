"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const React = __importStar(require("react"));
const react_select_1 = __importDefault(require("react-select"));
const immutable_1 = require("immutable");
const styles_1 = require("netlify-cms-ui-default/dist/esm/styles");
class Control extends React.Component {
    constructor() {
        super(...arguments);
        this.state = {
            options: [],
        };
        this.changeHandle = selected => {
            const { onChange } = this.props;
            if (!selected)
                onChange([]);
            const value = Array.isArray(selected)
                ? selected
                : [selected];
            onChange(immutable_1.fromJS(value));
        };
        this.getSelectedValue = (value, options) => {
            let selected = [];
            if (!value)
                return selected;
            else if (typeof value === 'string') {
                const maybeOption = options.find(option => option.value === value);
                selected = maybeOption ? [maybeOption] : [];
            }
            else
                selected = value.toJS();
            return selected;
        };
    }
    componentDidMount() {
        return __awaiter(this, void 0, void 0, function* () {
            const { loadEntry, field } = this.props;
            const collection = field.get('collection');
            const file = field.get('file');
            const fieldName = field.get('target_field');
            const fieldId = field.get('id_field');
            const fieldDisplay = field.get('display_fields') || fieldId;
            const results = yield loadEntry(collection, file);
            const data = results.data[fieldName];
            const options = data.map(option => {
                let value, label;
                if (typeof option === 'string') {
                    value = label = option;
                }
                else {
                    value = option[fieldId];
                    label = option[fieldDisplay];
                }
                return { value, label };
            });
            this.setState({ options });
        });
    }
    render() {
        const { field, value, forID, classNameWrapper, setActiveStyle, setInactiveStyle, } = this.props;
        const { options } = this.state;
        const selected = this.getSelectedValue(value, options);
        const isMultiple = field.get('multiple');
        const placeholder = field.get('placeholder') || 'select...';
        return (React.createElement("div", null,
            React.createElement(react_select_1.default, { inputId: forID, isMulti: isMultiple, onChange: this.changeHandle, className: classNameWrapper, onFocus: setActiveStyle, onBlur: setInactiveStyle, styles: styles_1.reactSelectStyles, name: "categories", isClearable: false, value: selected, options: options, placeholder: placeholder })));
    }
}
exports.Control = Control;
